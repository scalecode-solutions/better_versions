import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';
import 'package:better_versions/src/version_formatter.dart';
import 'package:better_versions/src/version_patterns.dart';

/// Manages versioning operations for Flutter/Dart projects
class VersionManager {
  final String projectRoot;
  final VersionFormat versionFormat;
  final bool dryRun;
  
  /// Create a new VersionManager
  VersionManager({
    required this.projectRoot,
    this.versionFormat = VersionFormat.semantic,
    this.dryRun = false,
  });
  
  /// Get the path to the pubspec.yaml file
  String get _pubspecPath => path.join(projectRoot, 'pubspec.yaml');
  
  /// Get the path to the version file (if using a separate version file)
  String get _versionFilePath => path.join(projectRoot, 'version.yaml');
  
  /// Get the current version from pubspec.yaml
  Future<Map<String, dynamic>> getCurrentVersion() async {
    final file = File(_pubspecPath);
    if (!await file.exists()) {
      throw Exception('pubspec.yaml not found at ${file.path}');
    }
    
    final content = await file.readAsString();
    final yaml = loadYaml(content);
    final versionString = yaml['version'] as String? ?? '0.0.1';
    
    return VersionFormatter.parseVersion(versionString);
  }
  
  /// Update the version in pubspec.yaml
  Future<void> updateVersion({
    int? major,
    int? minor,
    int? patch,
    int? buildNumber,
    String? preRelease,
    String? buildMetadata,
    bool autoIncrementBuild = false,
  }) async {
    // Read current version
    final current = await getCurrentVersion();
    
    // Calculate new version numbers
    final newMajor = major ?? current['major'] as int;
    final newMinor = minor ?? current['minor'] as int;
    final newPatch = patch ?? current['patch'] as int;
    
    // Handle build number
    int? newBuildNumber;
    if (buildNumber != null) {
      newBuildNumber = buildNumber;
    } else if (autoIncrementBuild) {
      final currentBuild = int.tryParse(current['buildMetadata'] ?? '0') ?? 0;
      newBuildNumber = currentBuild + 1;
    }
    
    // Format the new version string
    final formatter = VersionFormatter(
      format: versionFormat,
    );
    
    // Format the version with all components
    String newVersion = formatter.formatVersion(
      major: newMajor,
      minor: newMinor,
      patch: newPatch,
      buildNumber: newBuildNumber,
      buildMetadata: buildMetadata,
    );
    
    // Handle pre-release version if specified
    if (preRelease != null && preRelease.isNotEmpty) {
      // Insert pre-release after the version core (major.minor.patch)
      final versionParts = newVersion.split('+');
      final versionCore = versionParts[0];
      final buildPart = versionParts.length > 1 ? '+${versionParts[1]}' : '';
      newVersion = '$versionCore-$preRelease$buildPart';
    }
    
    if (dryRun) {
      if (kDebugMode) {
        print('Dry run - would update version to: $newVersion');
      }
      return;
    }
    
    // Update pubspec.yaml
    await _updatePubspecVersion(newVersion);
    
    // If using a separate version file, update that too
    if (await File(_versionFilePath).exists()) {
      await _updateVersionFile(newVersion);
    }
    
    if (kDebugMode) {
      print('Version updated to: $newVersion');
    }
  }
  
  /// Update the version in pubspec.yaml
  Future<void> _updatePubspecVersion(String newVersion) async {
    final file = File(_pubspecPath);
    final lines = await file.readAsLines();
    
    var updated = false;
    for (var i = 0; i < lines.length; i++) {
      if (lines[i].trim().startsWith('version:')) {
        lines[i] = 'version: $newVersion';
        updated = true;
        break;
      }
    }
    
    if (!updated) {
      // If version line doesn't exist, add it after the name field
      for (var i = 0; i < lines.length; i++) {
        if (lines[i].trim().startsWith('name:')) {
          lines.insert(i + 1, 'version: $newVersion');
          updated = true;
          break;
        }
      }
    }
    
    if (updated) {
      await file.writeAsString(lines.join('\n'));
    } else {
      throw Exception('Could not find or add version field in pubspec.yaml');
    }
  }
  
  /// Update a separate version file if it exists
  Future<void> _updateVersionFile(String newVersion) async {
    final file = File(_versionFilePath);
    final content = '''# This file is auto-generated by better_versions
version: $newVersion
''';
    await file.writeAsString(content);
  }
  
  /// Bump the major version
  Future<void> bumpMajor({bool resetMinorAndPatch = true}) async {
    final current = await getCurrentVersion();
    await updateVersion(
      major: (current['major'] as int) + 1,
      minor: resetMinorAndPatch ? 0 : current['minor'] as int,
      patch: resetMinorAndPatch ? 0 : current['patch'] as int,
      autoIncrementBuild: true,
    );
  }
  
  /// Bump the minor version
  Future<void> bumpMinor({bool resetPatch = true}) async {
    final current = await getCurrentVersion();
    await updateVersion(
      minor: (current['minor'] as int) + 1,
      patch: resetPatch ? 0 : current['patch'] as int,
      autoIncrementBuild: true,
    );
  }
  
  /// Bump the patch version
  Future<void> bumpPatch() async {
    final current = await getCurrentVersion();
    await updateVersion(
      patch: (current['patch'] as int) + 1,
      autoIncrementBuild: true,
    );
  }
  
  /// Set a pre-release version
  Future<void> setPreRelease(String preRelease) async {
    await updateVersion(preRelease: preRelease, autoIncrementBuild: true);
  }
  
  /// Remove pre-release version
  Future<void> removePreRelease() async {
    await updateVersion(preRelease: '');
  }
  
  /// Generate the next version based on the current version and commit messages
  Future<void> generateNextVersion({
    required List<String> commitMessages,
  }) async {
    bool hasBreakingChange = commitMessages.any((msg) => 
        msg.toLowerCase().contains('breaking change:') || 
        msg.toLowerCase().contains('!:'));
        
    bool hasFeature = commitMessages.any((msg) => 
        msg.toLowerCase().startsWith('feat') ||
        msg.toLowerCase().startsWith('feature'));
    
    if (hasBreakingChange) {
      await bumpMajor();
    } else if (hasFeature) {
      await bumpMinor();
    } else {
      await bumpPatch();
    }
  }
}
